"""
Video-on-demand (VOD)
"""
import xbmc
import xbmcaddon

from . import cache_api, kodiutils, nhk_api, url, utils
from .episode import Episode

EPISODE_CACHE = None
ADDON = xbmcaddon.Addon()

if ADDON.getSettingBool("use_backend"):
    xbmc.log("vod.py: Loading program metadata cache from Azure CDN")
    # Try to get the meta data cache from Azure CDN (it is a file)
    EPISODE_CACHE = cache_api.get_program_metdadata_cache()

    # Only use it if we got valid dict back
    if isinstance(EPISODE_CACHE, dict):
        USE_CACHE = True
        xbmc.log("vod.py: Loaded program metadata cache from Azure CDN")


def get_episode_list(api_method, episode_list_id, show_only_subtitle):
    """Video On Demand - Episode List

        Returns episode list based on the requested NHK API Method
        (e.g. Programs, Categories, etc.)

    Args:
        api_method ([str]): The NHK API method to use
        episode_list_id ([str]): ID to use (optional)
        show_only_subtitle ([bool]): Only show subtitles
    Returns:
        [list] -- List of episodes
    """

    # Only format api_url when a non-0 value for id was provided
    # some APIs do not need an id
    if episode_list_id != "None":
        api_url = nhk_api.rest_url[api_method].format(episode_list_id)
    else:
        api_url = nhk_api.rest_url[api_method]

    api_result_json = url.get_json(api_url)["data"]

    if "episodes" in api_result_json:
        # "Normal" episode list
        program_json = api_result_json["episodes"]
    elif "playlist" in api_result_json:
        # Episode List that is generated by the PlayList API
        program_json = api_result_json["playlist"][0]["track"]
    else:
        # Unknown source, abort
        return None

    episodes = []
    episode = None
    for row in program_json:
        episode = Episode()
        episode.is_playable = True
        title = row["title_clean"]
        subtitle = row["sub_title_clean"]

        if int(show_only_subtitle) == 1:
            # Show only subtitle
            if len(subtitle) > 0:
                # There is a subtitle, use it
                episode_name = subtitle
            else:
                # Use the title instead of the subtitle
                episode_name = title
        else:
            # Show complete title
            if len(title) == 0:
                # Use the subtitle as the episode name
                # because there is no title
                episode_name = subtitle
            else:
                # Use the full episode name
                episode_name = utils.get_episode_name(title, subtitle)

        episode.title = episode_name
        description = row["description_clean"]
        episode.thumb = row["image"]
        episode.fanart = row["image_l"]
        episode.vod_id = row["vod_id"]
        episode.pgm_no = row["pgm_no"]
        episode.duration = row["movie_duration"]

        # Check if we have an aired date
        broadcast_start_timestamp = row["onair"]

        if broadcast_start_timestamp is not None:
            episode.broadcast_start_date = broadcast_start_timestamp
            episode.broadcast_end_date = row["vod_to"]
            episode.plot_include_broadcast_detail = True

        episode.plot = description
        episodes.append(episode)
    return episodes


def get_episode_from_cache(episode, use_720p=False):
    """Add a Kodi directory item for a playable episode

    Args:
        episode ([Episode]): The episode
        use_720p ([boolean], optional): Use 720P or 1080p.
        Defaults to USE_720P from add-on settings

    Returns:
        [type]: [description]
    """
    # If the vod_id is in cache and cache is being used,
    # directly add the URL otherwise dynamically resolve it
    # via play_vod_episode()
    #
    # Use the cache backend or not
    return_value = None
    if episode.vod_id in EPISODE_CACHE:
        cached_episode = EPISODE_CACHE[episode.vod_id]
        # In cache - display directly
        # If we should use 720P or there is no 1080P file, use 720P
        if use_720p or cached_episode["P1080P"] is None:
            episode.url = cached_episode["P720P"]
            episode.video_info = kodiutils.get_video_info(use_720p=True)
        else:
            episode.url = cached_episode["P1080P"]
            episode.video_info = kodiutils.get_video_info(use_720p=False)
        episode.onair = cached_episode["OnAir"]

        return_value = [episode.url, episode.kodi_list_item, False]
        xbmc.log(
            f"vod.get_episode_from_cache: Added episode {episode.vod_id} from cache"
        )
    return return_value


def get_between(string, start, end):
    """Extracts a string between two other strings"""
    start_index = string.index(start) + len(start)
    end_index = string.index(end, start_index)
    return string[start_index:end_index]


def get_media_information_api_url(vod_id):
    """Extracts the Media Information Url from the NHK Web Player - very slow operation!

    Args:
        vod_id (string): VodId from the NHK Api

    Returns:
        string: A API url to get the media information
    """

    xbmc.log(f"vod.resolve_vod_episode: Using Player.js to retrieve vod_id: {vod_id}")
    request = url.get_url(nhk_api.rest_url["player_url"])
    if request.status_code == 200:
        contents = request.text

        # First, find the block in the js that contains the prod token and url
        prod_block = get_between(contents, "prod:{", "}.prod;")
        # Extract the relevant information
        api_url = get_between(prod_block, 'apiUrl:"', '"')
        token = get_between(prod_block, 'token:"', '"')
        media_information_url = (
            f"{api_url}/?token={token}&type=json&optional_id={vod_id}&active_flg=1"
        )

        # check if the URI is correct
        if media_information_url.startswith("http"):
            return media_information_url
        else:
            xbmc.log(
                f"Could not construct valid GetMediaInformationApiUrl: { media_information_url}"
            )
            return None


def resolve_vod_episode(vod_id, use_720p):
    """Resolve a VOD episode directly from NHK

    Args:
        vod_id ([str]): The VOD Id
        use_720p ([boolean]): Use 720P or 1080p.
        Defaults to USE_720P from add-on settings

    Returns:
        [Episode]: The resolved Episode - only used for unit testing
    """

    xbmc.log(
        f"vod.resolve_vod_episode: Getting episode information for vod_id: {vod_id}"
    )
    episode = None
    # Get episode detail
    episode_detail = url.get_json(
        nhk_api.rest_url["get_episode_detail"].format(vod_id)
    )["data"]["episodes"][0]
    # Fill the episode details
    episode = Episode()
    episode.vod_id = vod_id
    episode.title = episode_detail["title_clean"]
    episode.broadcast_start_date = episode_detail["onair"]
    episode.plot = episode_detail["description_clean"]
    episode.pgm_no = episode_detail["pgm_no"]
    episode.duration = episode_detail["movie_duration"]

    # # Get the media information from the streaming API
    xbmc.log(
        f"vod.resolve_vod_episode: Using Player to get media information API url for vod_id: {vod_id}"
    )
    api_url = get_media_information_api_url(vod_id)

    xbmc.log(
        f"vod.resolve_vod_episode: Getting episode media information from API for vod_id: {vod_id}"
    )
    media_information = url.get_json(api_url)["meta"][0]

    if isinstance(media_information, dict):
        # Valid JSON
        # Currently, we only support 720p because of the new streaming Api
        episode.url = media_information["movie_url"]["mb_hd"]
        xbmc.log(f"vod.resolve_vod_episode: Url vod_id: {vod_id}, Use 720p: {use_720p}")

        episode.video_info = kodiutils.get_video_info(use_720p=True)
        episode.is_playable = True

    return episode
